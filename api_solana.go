/*
Gallop API

Data and insights APIs, webooks, and dashboards enabling businesses to launch tokenized products in seconds.

API version: 1.0.0
Contact: support@higallop.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// SolanaApiService SolanaApi service
type SolanaApiService service

type ApiGetSolAccountNFTsRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolAccountNFTsRequest *GetSolAccountNFTsRequest
}

func (r ApiGetSolAccountNFTsRequest) GetSolAccountNFTsRequest(getSolAccountNFTsRequest GetSolAccountNFTsRequest) ApiGetSolAccountNFTsRequest {
	r.getSolAccountNFTsRequest = &getSolAccountNFTsRequest
	return r
}

func (r ApiGetSolAccountNFTsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolAccountNFTsExecute(r)
}

/*
GetSolAccountNFTs Tokens Owned by Wallet

Returns all tokens owned for a given wallet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolAccountNFTsRequest
*/
func (a *SolanaApiService) GetSolAccountNFTs(ctx context.Context) ApiGetSolAccountNFTsRequest {
	return ApiGetSolAccountNFTsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolAccountNFTsExecute(r ApiGetSolAccountNFTsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolAccountNFTs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/sol/getAccountNFTs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolAccountNFTsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolCollectionForecastsRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolCollectionForecastsRequest *GetSolCollectionForecastsRequest
}

func (r ApiGetSolCollectionForecastsRequest) GetSolCollectionForecastsRequest(getSolCollectionForecastsRequest GetSolCollectionForecastsRequest) ApiGetSolCollectionForecastsRequest {
	r.getSolCollectionForecastsRequest = &getSolCollectionForecastsRequest
	return r
}

func (r ApiGetSolCollectionForecastsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolCollectionForecastsExecute(r)
}

/*
GetSolCollectionForecasts Price Forecast by Collection

Returns price, return, and volatility forecast for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolCollectionForecastsRequest
*/
func (a *SolanaApiService) GetSolCollectionForecasts(ctx context.Context) ApiGetSolCollectionForecastsRequest {
	return ApiGetSolCollectionForecastsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolCollectionForecastsExecute(r ApiGetSolCollectionForecastsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolCollectionForecasts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/sol/getCollectionForecasts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolCollectionForecastsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolCollectionPriceDiffRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolCollectionPriceDiffRequest *GetSolCollectionPriceDiffRequest
}

func (r ApiGetSolCollectionPriceDiffRequest) GetSolCollectionPriceDiffRequest(getSolCollectionPriceDiffRequest GetSolCollectionPriceDiffRequest) ApiGetSolCollectionPriceDiffRequest {
	r.getSolCollectionPriceDiffRequest = &getSolCollectionPriceDiffRequest
	return r
}

func (r ApiGetSolCollectionPriceDiffRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolCollectionPriceDiffExecute(r)
}

/*
GetSolCollectionPriceDiff Price Differentiation by Trait

Returns how trait differentiates price for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolCollectionPriceDiffRequest
*/
func (a *SolanaApiService) GetSolCollectionPriceDiff(ctx context.Context) ApiGetSolCollectionPriceDiffRequest {
	return ApiGetSolCollectionPriceDiffRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolCollectionPriceDiffExecute(r ApiGetSolCollectionPriceDiffRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolCollectionPriceDiff")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/sol/getCollectionPriceDiff"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolCollectionPriceDiffRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolCollectionSalesOHLCRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolCollectionSalesOHLCRequest *GetSolCollectionSalesOHLCRequest
}

func (r ApiGetSolCollectionSalesOHLCRequest) GetSolCollectionSalesOHLCRequest(getSolCollectionSalesOHLCRequest GetSolCollectionSalesOHLCRequest) ApiGetSolCollectionSalesOHLCRequest {
	r.getSolCollectionSalesOHLCRequest = &getSolCollectionSalesOHLCRequest
	return r
}

func (r ApiGetSolCollectionSalesOHLCRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolCollectionSalesOHLCExecute(r)
}

/*
GetSolCollectionSalesOHLC Collection Sales Price Candlesticks

Returns collection sales price open, high, low, close and volume at a selected time interval

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolCollectionSalesOHLCRequest
*/
func (a *SolanaApiService) GetSolCollectionSalesOHLC(ctx context.Context) ApiGetSolCollectionSalesOHLCRequest {
	return ApiGetSolCollectionSalesOHLCRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolCollectionSalesOHLCExecute(r ApiGetSolCollectionSalesOHLCRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolCollectionSalesOHLC")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/sol/getCollectionSalesOHLC"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolCollectionSalesOHLCRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolCollectionSummaryRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolCollectionSummaryRequest *GetSolCollectionSummaryRequest
}

func (r ApiGetSolCollectionSummaryRequest) GetSolCollectionSummaryRequest(getSolCollectionSummaryRequest GetSolCollectionSummaryRequest) ApiGetSolCollectionSummaryRequest {
	r.getSolCollectionSummaryRequest = &getSolCollectionSummaryRequest
	return r
}

func (r ApiGetSolCollectionSummaryRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolCollectionSummaryExecute(r)
}

/*
GetSolCollectionSummary Summary Statistics by Collection

Returns summary analytics for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolCollectionSummaryRequest
*/
func (a *SolanaApiService) GetSolCollectionSummary(ctx context.Context) ApiGetSolCollectionSummaryRequest {
	return ApiGetSolCollectionSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolCollectionSummaryExecute(r ApiGetSolCollectionSummaryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolCollectionSummary")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/sol/getCollectionSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolCollectionSummaryRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolCollectionTraitsRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolCollectionTraitsRequest *GetSolCollectionTraitsRequest
}

func (r ApiGetSolCollectionTraitsRequest) GetSolCollectionTraitsRequest(getSolCollectionTraitsRequest GetSolCollectionTraitsRequest) ApiGetSolCollectionTraitsRequest {
	r.getSolCollectionTraitsRequest = &getSolCollectionTraitsRequest
	return r
}

func (r ApiGetSolCollectionTraitsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolCollectionTraitsExecute(r)
}

/*
GetSolCollectionTraits Traits by Collection

Returns a list of traits for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolCollectionTraitsRequest
*/
func (a *SolanaApiService) GetSolCollectionTraits(ctx context.Context) ApiGetSolCollectionTraitsRequest {
	return ApiGetSolCollectionTraitsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolCollectionTraitsExecute(r ApiGetSolCollectionTraitsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolCollectionTraits")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/sol/getCollectionTraits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolCollectionTraitsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolCollectionTransactionsRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolCollectionTransactionsRequest *GetSolCollectionTransactionsRequest
}

func (r ApiGetSolCollectionTransactionsRequest) GetSolCollectionTransactionsRequest(getSolCollectionTransactionsRequest GetSolCollectionTransactionsRequest) ApiGetSolCollectionTransactionsRequest {
	r.getSolCollectionTransactionsRequest = &getSolCollectionTransactionsRequest
	return r
}

func (r ApiGetSolCollectionTransactionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolCollectionTransactionsExecute(r)
}

/*
GetSolCollectionTransactions Transactions by Collections

Returns all transactions for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolCollectionTransactionsRequest
*/
func (a *SolanaApiService) GetSolCollectionTransactions(ctx context.Context) ApiGetSolCollectionTransactionsRequest {
	return ApiGetSolCollectionTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolCollectionTransactionsExecute(r ApiGetSolCollectionTransactionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolCollectionTransactions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/sol/getCollectionTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolCollectionTransactionsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolCollectionsRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolCollectionsRequest *GetSolCollectionsRequest
}

func (r ApiGetSolCollectionsRequest) GetSolCollectionsRequest(getSolCollectionsRequest GetSolCollectionsRequest) ApiGetSolCollectionsRequest {
	r.getSolCollectionsRequest = &getSolCollectionsRequest
	return r
}

func (r ApiGetSolCollectionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolCollectionsExecute(r)
}

/*
GetSolCollections Aggregated Collections Supported by Gallop

Returns all Gallop aggregated collections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolCollectionsRequest
*/
func (a *SolanaApiService) GetSolCollections(ctx context.Context) ApiGetSolCollectionsRequest {
	return ApiGetSolCollectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolCollectionsExecute(r ApiGetSolCollectionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolCollections")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/sol/getCollections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolCollectionsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolCustomCollectionRiskRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolCustomCollectionRiskRequest *GetSolCustomCollectionRiskRequest
}

func (r ApiGetSolCustomCollectionRiskRequest) GetSolCustomCollectionRiskRequest(getSolCustomCollectionRiskRequest GetSolCustomCollectionRiskRequest) ApiGetSolCustomCollectionRiskRequest {
	r.getSolCustomCollectionRiskRequest = &getSolCustomCollectionRiskRequest
	return r
}

func (r ApiGetSolCustomCollectionRiskRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolCustomCollectionRiskExecute(r)
}

/*
GetSolCustomCollectionRisk Custom Volatility & Risk Metrics by Collection

Returns summary of customizable volatility and risk metrics for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolCustomCollectionRiskRequest
*/
func (a *SolanaApiService) GetSolCustomCollectionRisk(ctx context.Context) ApiGetSolCustomCollectionRiskRequest {
	return ApiGetSolCustomCollectionRiskRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolCustomCollectionRiskExecute(r ApiGetSolCustomCollectionRiskRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolCustomCollectionRisk")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/sol/getCustomCollectionRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolCustomCollectionRiskRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolCustomTokenRiskRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolCustomTokenRiskRequest *GetSolCustomTokenRiskRequest
}

func (r ApiGetSolCustomTokenRiskRequest) GetSolCustomTokenRiskRequest(getSolCustomTokenRiskRequest GetSolCustomTokenRiskRequest) ApiGetSolCustomTokenRiskRequest {
	r.getSolCustomTokenRiskRequest = &getSolCustomTokenRiskRequest
	return r
}

func (r ApiGetSolCustomTokenRiskRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolCustomTokenRiskExecute(r)
}

/*
GetSolCustomTokenRisk Custom Volatility & Risk Metrics by Token

Returns summary of customizable volatility and risk metrics for a given token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolCustomTokenRiskRequest
*/
func (a *SolanaApiService) GetSolCustomTokenRisk(ctx context.Context) ApiGetSolCustomTokenRiskRequest {
	return ApiGetSolCustomTokenRiskRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolCustomTokenRiskExecute(r ApiGetSolCustomTokenRiskRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolCustomTokenRisk")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/sol/getCustomTokenRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolCustomTokenRiskRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolDefaultCollectionRiskRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolDefaultCollectionRiskRequest *GetSolDefaultCollectionRiskRequest
}

func (r ApiGetSolDefaultCollectionRiskRequest) GetSolDefaultCollectionRiskRequest(getSolDefaultCollectionRiskRequest GetSolDefaultCollectionRiskRequest) ApiGetSolDefaultCollectionRiskRequest {
	r.getSolDefaultCollectionRiskRequest = &getSolDefaultCollectionRiskRequest
	return r
}

func (r ApiGetSolDefaultCollectionRiskRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolDefaultCollectionRiskExecute(r)
}

/*
GetSolDefaultCollectionRisk Default Volatility & Risk Metrics by Collection

Returns summary of default volatility and risk metrics for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolDefaultCollectionRiskRequest
*/
func (a *SolanaApiService) GetSolDefaultCollectionRisk(ctx context.Context) ApiGetSolDefaultCollectionRiskRequest {
	return ApiGetSolDefaultCollectionRiskRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolDefaultCollectionRiskExecute(r ApiGetSolDefaultCollectionRiskRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolDefaultCollectionRisk")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/sol/getDefaultCollectionRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolDefaultCollectionRiskRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolDefaultTokenRiskRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolDefaultTokenRiskRequest *GetSolDefaultTokenRiskRequest
}

func (r ApiGetSolDefaultTokenRiskRequest) GetSolDefaultTokenRiskRequest(getSolDefaultTokenRiskRequest GetSolDefaultTokenRiskRequest) ApiGetSolDefaultTokenRiskRequest {
	r.getSolDefaultTokenRiskRequest = &getSolDefaultTokenRiskRequest
	return r
}

func (r ApiGetSolDefaultTokenRiskRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolDefaultTokenRiskExecute(r)
}

/*
GetSolDefaultTokenRisk Default Volatility & Risk Metrics by Token

Returns summary of default volatility and risk metrics for a given token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolDefaultTokenRiskRequest
*/
func (a *SolanaApiService) GetSolDefaultTokenRisk(ctx context.Context) ApiGetSolDefaultTokenRiskRequest {
	return ApiGetSolDefaultTokenRiskRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolDefaultTokenRiskExecute(r ApiGetSolDefaultTokenRiskRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolDefaultTokenRisk")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/sol/getDefaultTokenRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolDefaultTokenRiskRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolHistoricalTransactionsRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolHistoricalTransactionsRequest *GetSolHistoricalTransactionsRequest
}

func (r ApiGetSolHistoricalTransactionsRequest) GetSolHistoricalTransactionsRequest(getSolHistoricalTransactionsRequest GetSolHistoricalTransactionsRequest) ApiGetSolHistoricalTransactionsRequest {
	r.getSolHistoricalTransactionsRequest = &getSolHistoricalTransactionsRequest
	return r
}

func (r ApiGetSolHistoricalTransactionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolHistoricalTransactionsExecute(r)
}

/*
GetSolHistoricalTransactions Historical Transactions by Collection

Returns all transactions for a given collection in bulk

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolHistoricalTransactionsRequest
*/
func (a *SolanaApiService) GetSolHistoricalTransactions(ctx context.Context) ApiGetSolHistoricalTransactionsRequest {
	return ApiGetSolHistoricalTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolHistoricalTransactionsExecute(r ApiGetSolHistoricalTransactionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolHistoricalTransactions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/sol/getHistoricalTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolHistoricalTransactionsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolMarketplaceDataRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolMarketplaceDataRequest *GetSolMarketplaceDataRequest
}

func (r ApiGetSolMarketplaceDataRequest) GetSolMarketplaceDataRequest(getSolMarketplaceDataRequest GetSolMarketplaceDataRequest) ApiGetSolMarketplaceDataRequest {
	r.getSolMarketplaceDataRequest = &getSolMarketplaceDataRequest
	return r
}

func (r ApiGetSolMarketplaceDataRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolMarketplaceDataExecute(r)
}

/*
GetSolMarketplaceData Collection Summary by Marketplace

Returns summary statistics for collections by marketplace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolMarketplaceDataRequest
*/
func (a *SolanaApiService) GetSolMarketplaceData(ctx context.Context) ApiGetSolMarketplaceDataRequest {
	return ApiGetSolMarketplaceDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolMarketplaceDataExecute(r ApiGetSolMarketplaceDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolMarketplaceData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/sol/getMarketplaceData"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolMarketplaceDataRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolMarketplaceFloorPriceRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolMarketplaceFloorPriceRequest *GetSolMarketplaceFloorPriceRequest
}

func (r ApiGetSolMarketplaceFloorPriceRequest) GetSolMarketplaceFloorPriceRequest(getSolMarketplaceFloorPriceRequest GetSolMarketplaceFloorPriceRequest) ApiGetSolMarketplaceFloorPriceRequest {
	r.getSolMarketplaceFloorPriceRequest = &getSolMarketplaceFloorPriceRequest
	return r
}

func (r ApiGetSolMarketplaceFloorPriceRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolMarketplaceFloorPriceExecute(r)
}

/*
GetSolMarketplaceFloorPrice Marketplace Floor Price by Collection

Returns current floor price for all collections by marketplace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolMarketplaceFloorPriceRequest
*/
func (a *SolanaApiService) GetSolMarketplaceFloorPrice(ctx context.Context) ApiGetSolMarketplaceFloorPriceRequest {
	return ApiGetSolMarketplaceFloorPriceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolMarketplaceFloorPriceExecute(r ApiGetSolMarketplaceFloorPriceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolMarketplaceFloorPrice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/sol/getMarketplaceFloorPrice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolMarketplaceFloorPriceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolMarketplaceTraitDataRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolMarketplaceTraitDataRequest *GetSolMarketplaceTraitDataRequest
}

func (r ApiGetSolMarketplaceTraitDataRequest) GetSolMarketplaceTraitDataRequest(getSolMarketplaceTraitDataRequest GetSolMarketplaceTraitDataRequest) ApiGetSolMarketplaceTraitDataRequest {
	r.getSolMarketplaceTraitDataRequest = &getSolMarketplaceTraitDataRequest
	return r
}

func (r ApiGetSolMarketplaceTraitDataRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolMarketplaceTraitDataExecute(r)
}

/*
GetSolMarketplaceTraitData Collection Listings by Trait & Marketplace

Returns listing statistics for a collection by trait and marketplace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolMarketplaceTraitDataRequest
*/
func (a *SolanaApiService) GetSolMarketplaceTraitData(ctx context.Context) ApiGetSolMarketplaceTraitDataRequest {
	return ApiGetSolMarketplaceTraitDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolMarketplaceTraitDataExecute(r ApiGetSolMarketplaceTraitDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolMarketplaceTraitData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/sol/getMarketplaceTraitData"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolMarketplaceTraitDataRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolNFTAccountRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolNFTAccountRequest *GetSolNFTAccountRequest
}

func (r ApiGetSolNFTAccountRequest) GetSolNFTAccountRequest(getSolNFTAccountRequest GetSolNFTAccountRequest) ApiGetSolNFTAccountRequest {
	r.getSolNFTAccountRequest = &getSolNFTAccountRequest
	return r
}

func (r ApiGetSolNFTAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolNFTAccountExecute(r)
}

/*
GetSolNFTAccount Wallet Owners by Token

Returns all wallet owners for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolNFTAccountRequest
*/
func (a *SolanaApiService) GetSolNFTAccount(ctx context.Context) ApiGetSolNFTAccountRequest {
	return ApiGetSolNFTAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolNFTAccountExecute(r ApiGetSolNFTAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolNFTAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/sol/getNFTAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolNFTAccountRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolRarityRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolRarityRequest *GetSolRarityRequest
}

func (r ApiGetSolRarityRequest) GetSolRarityRequest(getSolRarityRequest GetSolRarityRequest) ApiGetSolRarityRequest {
	r.getSolRarityRequest = &getSolRarityRequest
	return r
}

func (r ApiGetSolRarityRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolRarityExecute(r)
}

/*
GetSolRarity Token Rarity by Collection

Returns rarity by token for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolRarityRequest
*/
func (a *SolanaApiService) GetSolRarity(ctx context.Context) ApiGetSolRarityRequest {
	return ApiGetSolRarityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolRarityExecute(r ApiGetSolRarityRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolRarity")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/sol/getRarity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolRarityRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolTokenAppraisalRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolTokenAppraisalRequest *GetSolTokenAppraisalRequest
}

func (r ApiGetSolTokenAppraisalRequest) GetSolTokenAppraisalRequest(getSolTokenAppraisalRequest GetSolTokenAppraisalRequest) ApiGetSolTokenAppraisalRequest {
	r.getSolTokenAppraisalRequest = &getSolTokenAppraisalRequest
	return r
}

func (r ApiGetSolTokenAppraisalRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolTokenAppraisalExecute(r)
}

/*
GetSolTokenAppraisal Liquidation & Appraisal Estimate by Token

Get estimates of appraisal and liquidation values for a set of tokens. The app returns nowcasts by default, but if provided a `horizon` and `frequency`, it will return forcasts for `horizon` periods out at interval `frequency`. The app is does not deliver individualized financial advice, but merely provides analytical estimates of token appraisal and liquidation values

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolTokenAppraisalRequest
*/
func (a *SolanaApiService) GetSolTokenAppraisal(ctx context.Context) ApiGetSolTokenAppraisalRequest {
	return ApiGetSolTokenAppraisalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolTokenAppraisalExecute(r ApiGetSolTokenAppraisalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolTokenAppraisal")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/sol/getTokenAppraisal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolTokenAppraisalRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolTokenForecastsRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolTokenForecastsRequest *GetSolTokenForecastsRequest
}

func (r ApiGetSolTokenForecastsRequest) GetSolTokenForecastsRequest(getSolTokenForecastsRequest GetSolTokenForecastsRequest) ApiGetSolTokenForecastsRequest {
	r.getSolTokenForecastsRequest = &getSolTokenForecastsRequest
	return r
}

func (r ApiGetSolTokenForecastsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolTokenForecastsExecute(r)
}

/*
GetSolTokenForecasts Price Forecast by Token

Returns price, return, and volatility forecast for a given token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolTokenForecastsRequest
*/
func (a *SolanaApiService) GetSolTokenForecasts(ctx context.Context) ApiGetSolTokenForecastsRequest {
	return ApiGetSolTokenForecastsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolTokenForecastsExecute(r ApiGetSolTokenForecastsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolTokenForecasts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/sol/getTokenForecasts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolTokenForecastsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolTokenSummaryRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolTokenSummaryRequest *GetSolTokenSummaryRequest
}

func (r ApiGetSolTokenSummaryRequest) GetSolTokenSummaryRequest(getSolTokenSummaryRequest GetSolTokenSummaryRequest) ApiGetSolTokenSummaryRequest {
	r.getSolTokenSummaryRequest = &getSolTokenSummaryRequest
	return r
}

func (r ApiGetSolTokenSummaryRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolTokenSummaryExecute(r)
}

/*
GetSolTokenSummary Summary Statistics by Token

Returns summary analytics for a given token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolTokenSummaryRequest
*/
func (a *SolanaApiService) GetSolTokenSummary(ctx context.Context) ApiGetSolTokenSummaryRequest {
	return ApiGetSolTokenSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolTokenSummaryExecute(r ApiGetSolTokenSummaryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolTokenSummary")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/sol/getTokenSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolTokenSummaryRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolTokenTransactionsRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolTokenTransactionsRequest *GetSolTokenTransactionsRequest
}

func (r ApiGetSolTokenTransactionsRequest) GetSolTokenTransactionsRequest(getSolTokenTransactionsRequest GetSolTokenTransactionsRequest) ApiGetSolTokenTransactionsRequest {
	r.getSolTokenTransactionsRequest = &getSolTokenTransactionsRequest
	return r
}

func (r ApiGetSolTokenTransactionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolTokenTransactionsExecute(r)
}

/*
GetSolTokenTransactions Transactions by Token

Returns all transactions for a given token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolTokenTransactionsRequest
*/
func (a *SolanaApiService) GetSolTokenTransactions(ctx context.Context) ApiGetSolTokenTransactionsRequest {
	return ApiGetSolTokenTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolTokenTransactionsExecute(r ApiGetSolTokenTransactionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolTokenTransactions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/sol/getTokenTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolTokenTransactionsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolTokensRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolTokensRequest *GetSolTokensRequest
}

func (r ApiGetSolTokensRequest) GetSolTokensRequest(getSolTokensRequest GetSolTokensRequest) ApiGetSolTokensRequest {
	r.getSolTokensRequest = &getSolTokensRequest
	return r
}

func (r ApiGetSolTokensRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolTokensExecute(r)
}

/*
GetSolTokens Tokens by Collection

Returns all tokens for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolTokensRequest
*/
func (a *SolanaApiService) GetSolTokens(ctx context.Context) ApiGetSolTokensRequest {
	return ApiGetSolTokensRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolTokensExecute(r ApiGetSolTokensRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolTokens")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/sol/getTokens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolTokensRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolWashTradeRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolWashTradeRequest *GetSolWashTradeRequest
}

func (r ApiGetSolWashTradeRequest) GetSolWashTradeRequest(getSolWashTradeRequest GetSolWashTradeRequest) ApiGetSolWashTradeRequest {
	r.getSolWashTradeRequest = &getSolWashTradeRequest
	return r
}

func (r ApiGetSolWashTradeRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolWashTradeExecute(r)
}

/*
GetSolWashTrade Wash Trades by Transaction

Returns suspected wash trades for a given transaction hash

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolWashTradeRequest
*/
func (a *SolanaApiService) GetSolWashTrade(ctx context.Context) ApiGetSolWashTradeRequest {
	return ApiGetSolWashTradeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolWashTradeExecute(r ApiGetSolWashTradeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolWashTrade")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/sol/getWashTrade"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolWashTradeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSolWashTransactionsRequest struct {
	ctx context.Context
	ApiService *SolanaApiService
	getSolWashTransactionsRequest *GetSolWashTransactionsRequest
}

func (r ApiGetSolWashTransactionsRequest) GetSolWashTransactionsRequest(getSolWashTransactionsRequest GetSolWashTransactionsRequest) ApiGetSolWashTransactionsRequest {
	r.getSolWashTransactionsRequest = &getSolWashTransactionsRequest
	return r
}

func (r ApiGetSolWashTransactionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSolWashTransactionsExecute(r)
}

/*
GetSolWashTransactions Wash Trades by Collection

Returns suspected wash trades by token for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSolWashTransactionsRequest
*/
func (a *SolanaApiService) GetSolWashTransactions(ctx context.Context) ApiGetSolWashTransactionsRequest {
	return ApiGetSolWashTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SolanaApiService) GetSolWashTransactionsExecute(r ApiGetSolWashTransactionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SolanaApiService.GetSolWashTransactions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/sol/getWashTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSolWashTransactionsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
