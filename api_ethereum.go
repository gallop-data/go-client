/*
Gallop API

Data and insights APIs, webooks, and dashboards enabling businesses to launch tokenized products in seconds.

API version: 1.0.0
Contact: support@higallop.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// EthereumApiService EthereumApi service
type EthereumApiService service

type ApiGetEthCollectionFloorPriceOHLCRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthCollectionFloorPriceOHLCRequest *GetEthCollectionFloorPriceOHLCRequest
}

func (r ApiGetEthCollectionFloorPriceOHLCRequest) GetEthCollectionFloorPriceOHLCRequest(getEthCollectionFloorPriceOHLCRequest GetEthCollectionFloorPriceOHLCRequest) ApiGetEthCollectionFloorPriceOHLCRequest {
	r.getEthCollectionFloorPriceOHLCRequest = &getEthCollectionFloorPriceOHLCRequest
	return r
}

func (r ApiGetEthCollectionFloorPriceOHLCRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthCollectionFloorPriceOHLCExecute(r)
}

/*
GetEthCollectionFloorPriceOHLC Intraday Marketplace Floor Price by Collection

Returns intraday floor price for a given collection by marketplace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthCollectionFloorPriceOHLCRequest
*/
func (a *EthereumApiService) GetEthCollectionFloorPriceOHLC(ctx context.Context) ApiGetEthCollectionFloorPriceOHLCRequest {
	return ApiGetEthCollectionFloorPriceOHLCRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthCollectionFloorPriceOHLCExecute(r ApiGetEthCollectionFloorPriceOHLCRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthCollectionFloorPriceOHLC")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/eth/getCollectionFloorPriceOHLC"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthCollectionFloorPriceOHLCRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthCollectionForecastsRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthCollectionForecastsRequest *GetEthCollectionForecastsRequest
}

func (r ApiGetEthCollectionForecastsRequest) GetEthCollectionForecastsRequest(getEthCollectionForecastsRequest GetEthCollectionForecastsRequest) ApiGetEthCollectionForecastsRequest {
	r.getEthCollectionForecastsRequest = &getEthCollectionForecastsRequest
	return r
}

func (r ApiGetEthCollectionForecastsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthCollectionForecastsExecute(r)
}

/*
GetEthCollectionForecasts Price Forecast by Collection

Returns price, return, and volatility forecast for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthCollectionForecastsRequest
*/
func (a *EthereumApiService) GetEthCollectionForecasts(ctx context.Context) ApiGetEthCollectionForecastsRequest {
	return ApiGetEthCollectionForecastsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthCollectionForecastsExecute(r ApiGetEthCollectionForecastsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthCollectionForecasts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/eth/getCollectionForecasts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthCollectionForecastsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthCollectionListingsOHLCRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthCollectionListingsOHLCRequest *GetEthCollectionListingsOHLCRequest
}

func (r ApiGetEthCollectionListingsOHLCRequest) GetEthCollectionListingsOHLCRequest(getEthCollectionListingsOHLCRequest GetEthCollectionListingsOHLCRequest) ApiGetEthCollectionListingsOHLCRequest {
	r.getEthCollectionListingsOHLCRequest = &getEthCollectionListingsOHLCRequest
	return r
}

func (r ApiGetEthCollectionListingsOHLCRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthCollectionListingsOHLCExecute(r)
}

/*
GetEthCollectionListingsOHLC Collection Floor Price and Listings Candlesticks

Returns historical floor price or more extensive open / high / floor / close candlesticks for collection listings at marketplaces at a selected time interval, as well as the number of active listings, the number of unique owners and the average age of open listings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthCollectionListingsOHLCRequest
*/
func (a *EthereumApiService) GetEthCollectionListingsOHLC(ctx context.Context) ApiGetEthCollectionListingsOHLCRequest {
	return ApiGetEthCollectionListingsOHLCRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthCollectionListingsOHLCExecute(r ApiGetEthCollectionListingsOHLCRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthCollectionListingsOHLC")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/eth/getCollectionListingsOHLC"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthCollectionListingsOHLCRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthCollectionOwnersRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthCollectionOwnersRequest *GetEthCollectionOwnersRequest
}

func (r ApiGetEthCollectionOwnersRequest) GetEthCollectionOwnersRequest(getEthCollectionOwnersRequest GetEthCollectionOwnersRequest) ApiGetEthCollectionOwnersRequest {
	r.getEthCollectionOwnersRequest = &getEthCollectionOwnersRequest
	return r
}

func (r ApiGetEthCollectionOwnersRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthCollectionOwnersExecute(r)
}

/*
GetEthCollectionOwners Wallet Owners by Collection

Returns all wallet owners for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthCollectionOwnersRequest
*/
func (a *EthereumApiService) GetEthCollectionOwners(ctx context.Context) ApiGetEthCollectionOwnersRequest {
	return ApiGetEthCollectionOwnersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthCollectionOwnersExecute(r ApiGetEthCollectionOwnersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthCollectionOwners")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/eth/getCollectionOwners"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthCollectionOwnersRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthCollectionPriceDiffRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthCollectionPriceDiffRequest *GetEthCollectionPriceDiffRequest
}

func (r ApiGetEthCollectionPriceDiffRequest) GetEthCollectionPriceDiffRequest(getEthCollectionPriceDiffRequest GetEthCollectionPriceDiffRequest) ApiGetEthCollectionPriceDiffRequest {
	r.getEthCollectionPriceDiffRequest = &getEthCollectionPriceDiffRequest
	return r
}

func (r ApiGetEthCollectionPriceDiffRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthCollectionPriceDiffExecute(r)
}

/*
GetEthCollectionPriceDiff Price Differentiation by Trait

Returns how trait differentiates price for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthCollectionPriceDiffRequest
*/
func (a *EthereumApiService) GetEthCollectionPriceDiff(ctx context.Context) ApiGetEthCollectionPriceDiffRequest {
	return ApiGetEthCollectionPriceDiffRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthCollectionPriceDiffExecute(r ApiGetEthCollectionPriceDiffRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthCollectionPriceDiff")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/eth/getCollectionPriceDiff"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthCollectionPriceDiffRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthCollectionSalesOHLCRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthCollectionSalesOHLCRequest *GetEthCollectionSalesOHLCRequest
}

func (r ApiGetEthCollectionSalesOHLCRequest) GetEthCollectionSalesOHLCRequest(getEthCollectionSalesOHLCRequest GetEthCollectionSalesOHLCRequest) ApiGetEthCollectionSalesOHLCRequest {
	r.getEthCollectionSalesOHLCRequest = &getEthCollectionSalesOHLCRequest
	return r
}

func (r ApiGetEthCollectionSalesOHLCRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthCollectionSalesOHLCExecute(r)
}

/*
GetEthCollectionSalesOHLC Collection Sales Price Candlesticks

Returns collection sales price open, high, low, close and volume at a selected time interval

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthCollectionSalesOHLCRequest
*/
func (a *EthereumApiService) GetEthCollectionSalesOHLC(ctx context.Context) ApiGetEthCollectionSalesOHLCRequest {
	return ApiGetEthCollectionSalesOHLCRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthCollectionSalesOHLCExecute(r ApiGetEthCollectionSalesOHLCRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthCollectionSalesOHLC")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/eth/getCollectionSalesOHLC"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthCollectionSalesOHLCRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthCollectionSummaryRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthCollectionSummaryRequest *GetEthCollectionSummaryRequest
}

func (r ApiGetEthCollectionSummaryRequest) GetEthCollectionSummaryRequest(getEthCollectionSummaryRequest GetEthCollectionSummaryRequest) ApiGetEthCollectionSummaryRequest {
	r.getEthCollectionSummaryRequest = &getEthCollectionSummaryRequest
	return r
}

func (r ApiGetEthCollectionSummaryRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthCollectionSummaryExecute(r)
}

/*
GetEthCollectionSummary Summary Statistics by Collection

Returns summary analytics for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthCollectionSummaryRequest
*/
func (a *EthereumApiService) GetEthCollectionSummary(ctx context.Context) ApiGetEthCollectionSummaryRequest {
	return ApiGetEthCollectionSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthCollectionSummaryExecute(r ApiGetEthCollectionSummaryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthCollectionSummary")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/eth/getCollectionSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthCollectionSummaryRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthCollectionTransactionsRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthCollectionTransactionsRequest *GetEthCollectionTransactionsRequest
}

func (r ApiGetEthCollectionTransactionsRequest) GetEthCollectionTransactionsRequest(getEthCollectionTransactionsRequest GetEthCollectionTransactionsRequest) ApiGetEthCollectionTransactionsRequest {
	r.getEthCollectionTransactionsRequest = &getEthCollectionTransactionsRequest
	return r
}

func (r ApiGetEthCollectionTransactionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthCollectionTransactionsExecute(r)
}

/*
GetEthCollectionTransactions Transactions by Collection

Returns all transactions for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthCollectionTransactionsRequest
*/
func (a *EthereumApiService) GetEthCollectionTransactions(ctx context.Context) ApiGetEthCollectionTransactionsRequest {
	return ApiGetEthCollectionTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthCollectionTransactionsExecute(r ApiGetEthCollectionTransactionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthCollectionTransactions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/eth/getCollectionTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthCollectionTransactionsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthCollectionsRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthCollectionsRequest *GetEthCollectionsRequest
}

func (r ApiGetEthCollectionsRequest) GetEthCollectionsRequest(getEthCollectionsRequest GetEthCollectionsRequest) ApiGetEthCollectionsRequest {
	r.getEthCollectionsRequest = &getEthCollectionsRequest
	return r
}

func (r ApiGetEthCollectionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthCollectionsExecute(r)
}

/*
GetEthCollections Aggregated Collections Supported by Gallop

Returns all Gallop aggregated collections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthCollectionsRequest
*/
func (a *EthereumApiService) GetEthCollections(ctx context.Context) ApiGetEthCollectionsRequest {
	return ApiGetEthCollectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthCollectionsExecute(r ApiGetEthCollectionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthCollections")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/eth/getCollections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthCollectionsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthCustomCollectionRiskRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthCustomCollectionRiskRequest *GetEthCustomCollectionRiskRequest
}

func (r ApiGetEthCustomCollectionRiskRequest) GetEthCustomCollectionRiskRequest(getEthCustomCollectionRiskRequest GetEthCustomCollectionRiskRequest) ApiGetEthCustomCollectionRiskRequest {
	r.getEthCustomCollectionRiskRequest = &getEthCustomCollectionRiskRequest
	return r
}

func (r ApiGetEthCustomCollectionRiskRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthCustomCollectionRiskExecute(r)
}

/*
GetEthCustomCollectionRisk Custom Volatility & Risk Metrics by Collection

Returns summary of customizable volatility and risk metrics for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthCustomCollectionRiskRequest
*/
func (a *EthereumApiService) GetEthCustomCollectionRisk(ctx context.Context) ApiGetEthCustomCollectionRiskRequest {
	return ApiGetEthCustomCollectionRiskRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthCustomCollectionRiskExecute(r ApiGetEthCustomCollectionRiskRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthCustomCollectionRisk")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/eth/getCustomCollectionRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthCustomCollectionRiskRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthCustomTokenRiskRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthCustomTokenRiskRequest *GetEthCustomTokenRiskRequest
}

func (r ApiGetEthCustomTokenRiskRequest) GetEthCustomTokenRiskRequest(getEthCustomTokenRiskRequest GetEthCustomTokenRiskRequest) ApiGetEthCustomTokenRiskRequest {
	r.getEthCustomTokenRiskRequest = &getEthCustomTokenRiskRequest
	return r
}

func (r ApiGetEthCustomTokenRiskRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthCustomTokenRiskExecute(r)
}

/*
GetEthCustomTokenRisk Custom Volatility & Risk Metrics by Token

Returns summary of customizable volatility and risk metrics for a given token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthCustomTokenRiskRequest
*/
func (a *EthereumApiService) GetEthCustomTokenRisk(ctx context.Context) ApiGetEthCustomTokenRiskRequest {
	return ApiGetEthCustomTokenRiskRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthCustomTokenRiskExecute(r ApiGetEthCustomTokenRiskRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthCustomTokenRisk")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/eth/getCustomTokenRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthCustomTokenRiskRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthDefaultCollectionRiskRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthDefaultCollectionRiskRequest *GetEthDefaultCollectionRiskRequest
}

func (r ApiGetEthDefaultCollectionRiskRequest) GetEthDefaultCollectionRiskRequest(getEthDefaultCollectionRiskRequest GetEthDefaultCollectionRiskRequest) ApiGetEthDefaultCollectionRiskRequest {
	r.getEthDefaultCollectionRiskRequest = &getEthDefaultCollectionRiskRequest
	return r
}

func (r ApiGetEthDefaultCollectionRiskRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthDefaultCollectionRiskExecute(r)
}

/*
GetEthDefaultCollectionRisk Default Volatility & Risk Metrics by Collection

Returns summary of default volatility and risk metrics for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthDefaultCollectionRiskRequest
*/
func (a *EthereumApiService) GetEthDefaultCollectionRisk(ctx context.Context) ApiGetEthDefaultCollectionRiskRequest {
	return ApiGetEthDefaultCollectionRiskRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthDefaultCollectionRiskExecute(r ApiGetEthDefaultCollectionRiskRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthDefaultCollectionRisk")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/eth/getDefaultCollectionRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthDefaultCollectionRiskRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthDefaultTokenRiskRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthDefaultTokenRiskRequest *GetEthDefaultTokenRiskRequest
}

func (r ApiGetEthDefaultTokenRiskRequest) GetEthDefaultTokenRiskRequest(getEthDefaultTokenRiskRequest GetEthDefaultTokenRiskRequest) ApiGetEthDefaultTokenRiskRequest {
	r.getEthDefaultTokenRiskRequest = &getEthDefaultTokenRiskRequest
	return r
}

func (r ApiGetEthDefaultTokenRiskRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthDefaultTokenRiskExecute(r)
}

/*
GetEthDefaultTokenRisk Default Volatility & Risk Metrics by Token

Returns summary of default volatility and risk metrics for a given token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthDefaultTokenRiskRequest
*/
func (a *EthereumApiService) GetEthDefaultTokenRisk(ctx context.Context) ApiGetEthDefaultTokenRiskRequest {
	return ApiGetEthDefaultTokenRiskRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthDefaultTokenRiskExecute(r ApiGetEthDefaultTokenRiskRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthDefaultTokenRisk")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/eth/getDefaultTokenRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthDefaultTokenRiskRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthEnsLookupRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthEnsLookupRequest *GetEthEnsLookupRequest
}

func (r ApiGetEthEnsLookupRequest) GetEthEnsLookupRequest(getEthEnsLookupRequest GetEthEnsLookupRequest) ApiGetEthEnsLookupRequest {
	r.getEthEnsLookupRequest = &getEthEnsLookupRequest
	return r
}

func (r ApiGetEthEnsLookupRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthEnsLookupExecute(r)
}

/*
GetEthEnsLookup ENS Lookup

Returns Ethereum Name Service data for a given wallet address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthEnsLookupRequest
*/
func (a *EthereumApiService) GetEthEnsLookup(ctx context.Context) ApiGetEthEnsLookupRequest {
	return ApiGetEthEnsLookupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthEnsLookupExecute(r ApiGetEthEnsLookupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthEnsLookup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/eth/getEnsLookup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthEnsLookupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthHistoricalEventsRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthHistoricalEventsRequest *GetEthHistoricalEventsRequest
}

func (r ApiGetEthHistoricalEventsRequest) GetEthHistoricalEventsRequest(getEthHistoricalEventsRequest GetEthHistoricalEventsRequest) ApiGetEthHistoricalEventsRequest {
	r.getEthHistoricalEventsRequest = &getEthHistoricalEventsRequest
	return r
}

func (r ApiGetEthHistoricalEventsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthHistoricalEventsExecute(r)
}

/*
GetEthHistoricalEvents Marketplace Activity by Collection

Returns marketplace activity for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthHistoricalEventsRequest
*/
func (a *EthereumApiService) GetEthHistoricalEvents(ctx context.Context) ApiGetEthHistoricalEventsRequest {
	return ApiGetEthHistoricalEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthHistoricalEventsExecute(r ApiGetEthHistoricalEventsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthHistoricalEvents")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/eth/getHistoricalEvents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthHistoricalEventsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthHistoricalTransactionsRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthHistoricalTransactionsRequest *GetEthHistoricalTransactionsRequest
}

func (r ApiGetEthHistoricalTransactionsRequest) GetEthHistoricalTransactionsRequest(getEthHistoricalTransactionsRequest GetEthHistoricalTransactionsRequest) ApiGetEthHistoricalTransactionsRequest {
	r.getEthHistoricalTransactionsRequest = &getEthHistoricalTransactionsRequest
	return r
}

func (r ApiGetEthHistoricalTransactionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthHistoricalTransactionsExecute(r)
}

/*
GetEthHistoricalTransactions Historical Transactions by Collection

Returns all transactions for a given collection in bulk

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthHistoricalTransactionsRequest
*/
func (a *EthereumApiService) GetEthHistoricalTransactions(ctx context.Context) ApiGetEthHistoricalTransactionsRequest {
	return ApiGetEthHistoricalTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthHistoricalTransactionsExecute(r ApiGetEthHistoricalTransactionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthHistoricalTransactions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/eth/getHistoricalTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthHistoricalTransactionsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthLeaderBoardRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthLeaderBoardRequest *GetEthLeaderBoardRequest
}

func (r ApiGetEthLeaderBoardRequest) GetEthLeaderBoardRequest(getEthLeaderBoardRequest GetEthLeaderBoardRequest) ApiGetEthLeaderBoardRequest {
	r.getEthLeaderBoardRequest = &getEthLeaderBoardRequest
	return r
}

func (r ApiGetEthLeaderBoardRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthLeaderBoardExecute(r)
}

/*
GetEthLeaderBoard Ethereum Leaderboard by Collection

Returns top collections by volume transaction volume or sales count

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthLeaderBoardRequest
*/
func (a *EthereumApiService) GetEthLeaderBoard(ctx context.Context) ApiGetEthLeaderBoardRequest {
	return ApiGetEthLeaderBoardRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthLeaderBoardExecute(r ApiGetEthLeaderBoardRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthLeaderBoard")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/eth/getLeaderBoard"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthLeaderBoardRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthLiveListingsRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthLiveListingsRequest *GetEthLiveListingsRequest
}

func (r ApiGetEthLiveListingsRequest) GetEthLiveListingsRequest(getEthLiveListingsRequest GetEthLiveListingsRequest) ApiGetEthLiveListingsRequest {
	r.getEthLiveListingsRequest = &getEthLiveListingsRequest
	return r
}

func (r ApiGetEthLiveListingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthLiveListingsExecute(r)
}

/*
GetEthLiveListings Collection live listings

Returns live listings for a collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthLiveListingsRequest
*/
func (a *EthereumApiService) GetEthLiveListings(ctx context.Context) ApiGetEthLiveListingsRequest {
	return ApiGetEthLiveListingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthLiveListingsExecute(r ApiGetEthLiveListingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthLiveListings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/eth/getLiveListings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthLiveListingsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthLiveOffersRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthLiveListingsRequest *GetEthLiveListingsRequest
}

func (r ApiGetEthLiveOffersRequest) GetEthLiveListingsRequest(getEthLiveListingsRequest GetEthLiveListingsRequest) ApiGetEthLiveOffersRequest {
	r.getEthLiveListingsRequest = &getEthLiveListingsRequest
	return r
}

func (r ApiGetEthLiveOffersRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthLiveOffersExecute(r)
}

/*
GetEthLiveOffers Collection live offers

Returns live offers for a collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthLiveOffersRequest
*/
func (a *EthereumApiService) GetEthLiveOffers(ctx context.Context) ApiGetEthLiveOffersRequest {
	return ApiGetEthLiveOffersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthLiveOffersExecute(r ApiGetEthLiveOffersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthLiveOffers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/eth/getLiveOffers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthLiveListingsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthMarketplaceDataRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthMarketplaceDataRequest *GetEthMarketplaceDataRequest
}

func (r ApiGetEthMarketplaceDataRequest) GetEthMarketplaceDataRequest(getEthMarketplaceDataRequest GetEthMarketplaceDataRequest) ApiGetEthMarketplaceDataRequest {
	r.getEthMarketplaceDataRequest = &getEthMarketplaceDataRequest
	return r
}

func (r ApiGetEthMarketplaceDataRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthMarketplaceDataExecute(r)
}

/*
GetEthMarketplaceData Collection Summary by Marketplace

Returns summary statistics for a collection by marketplace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthMarketplaceDataRequest
*/
func (a *EthereumApiService) GetEthMarketplaceData(ctx context.Context) ApiGetEthMarketplaceDataRequest {
	return ApiGetEthMarketplaceDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthMarketplaceDataExecute(r ApiGetEthMarketplaceDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthMarketplaceData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/eth/getMarketplaceData"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthMarketplaceDataRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthMarketplaceFloorPriceRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthMarketplaceFloorPriceRequest *GetEthMarketplaceFloorPriceRequest
}

func (r ApiGetEthMarketplaceFloorPriceRequest) GetEthMarketplaceFloorPriceRequest(getEthMarketplaceFloorPriceRequest GetEthMarketplaceFloorPriceRequest) ApiGetEthMarketplaceFloorPriceRequest {
	r.getEthMarketplaceFloorPriceRequest = &getEthMarketplaceFloorPriceRequest
	return r
}

func (r ApiGetEthMarketplaceFloorPriceRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthMarketplaceFloorPriceExecute(r)
}

/*
GetEthMarketplaceFloorPrice Marketplace Floor Price by Collection

Returns current floor price for all collections by marketplace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthMarketplaceFloorPriceRequest
*/
func (a *EthereumApiService) GetEthMarketplaceFloorPrice(ctx context.Context) ApiGetEthMarketplaceFloorPriceRequest {
	return ApiGetEthMarketplaceFloorPriceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthMarketplaceFloorPriceExecute(r ApiGetEthMarketplaceFloorPriceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthMarketplaceFloorPrice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/eth/getMarketplaceFloorPrice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthMarketplaceFloorPriceRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthMarketplaceTraitDataRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthMarketplaceTraitDataRequest *GetEthMarketplaceTraitDataRequest
}

func (r ApiGetEthMarketplaceTraitDataRequest) GetEthMarketplaceTraitDataRequest(getEthMarketplaceTraitDataRequest GetEthMarketplaceTraitDataRequest) ApiGetEthMarketplaceTraitDataRequest {
	r.getEthMarketplaceTraitDataRequest = &getEthMarketplaceTraitDataRequest
	return r
}

func (r ApiGetEthMarketplaceTraitDataRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthMarketplaceTraitDataExecute(r)
}

/*
GetEthMarketplaceTraitData Collection Listings by Trait & Marketplace

Returns listing statistics for a collection by trait and marketplace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthMarketplaceTraitDataRequest
*/
func (a *EthereumApiService) GetEthMarketplaceTraitData(ctx context.Context) ApiGetEthMarketplaceTraitDataRequest {
	return ApiGetEthMarketplaceTraitDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthMarketplaceTraitDataExecute(r ApiGetEthMarketplaceTraitDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthMarketplaceTraitData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/eth/getMarketplaceTraitData"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthMarketplaceTraitDataRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthRarityRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthRarityRequest *GetEthRarityRequest
}

func (r ApiGetEthRarityRequest) GetEthRarityRequest(getEthRarityRequest GetEthRarityRequest) ApiGetEthRarityRequest {
	r.getEthRarityRequest = &getEthRarityRequest
	return r
}

func (r ApiGetEthRarityRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthRarityExecute(r)
}

/*
GetEthRarity Token Rarity by Collection

Returns rarity by token for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthRarityRequest
*/
func (a *EthereumApiService) GetEthRarity(ctx context.Context) ApiGetEthRarityRequest {
	return ApiGetEthRarityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthRarityExecute(r ApiGetEthRarityRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthRarity")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/eth/getRarity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthRarityRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthTokenAppraisalRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthTokenAppraisalRequest *GetEthTokenAppraisalRequest
}

func (r ApiGetEthTokenAppraisalRequest) GetEthTokenAppraisalRequest(getEthTokenAppraisalRequest GetEthTokenAppraisalRequest) ApiGetEthTokenAppraisalRequest {
	r.getEthTokenAppraisalRequest = &getEthTokenAppraisalRequest
	return r
}

func (r ApiGetEthTokenAppraisalRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthTokenAppraisalExecute(r)
}

/*
GetEthTokenAppraisal Liquidation & Appraisal Estimate by Token

Get estimates of appraisal and liquidation values for a set of tokens. The app returns nowcasts by default, but if provided a `horizon` and `frequency`, it will return forcasts for `horizon` periods out at interval `frequency`. The app is does not deliver individualized financial advice, but merely provides analytical estimates of token appraisal and liquidation values

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthTokenAppraisalRequest
*/
func (a *EthereumApiService) GetEthTokenAppraisal(ctx context.Context) ApiGetEthTokenAppraisalRequest {
	return ApiGetEthTokenAppraisalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthTokenAppraisalExecute(r ApiGetEthTokenAppraisalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthTokenAppraisal")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/eth/getTokenAppraisal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthTokenAppraisalRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthTokenForecastsRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthTokenForecastsRequest *GetEthTokenForecastsRequest
}

func (r ApiGetEthTokenForecastsRequest) GetEthTokenForecastsRequest(getEthTokenForecastsRequest GetEthTokenForecastsRequest) ApiGetEthTokenForecastsRequest {
	r.getEthTokenForecastsRequest = &getEthTokenForecastsRequest
	return r
}

func (r ApiGetEthTokenForecastsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthTokenForecastsExecute(r)
}

/*
GetEthTokenForecasts Price Forecast by Token

Returns price, return, and volatility forecast for a given token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthTokenForecastsRequest
*/
func (a *EthereumApiService) GetEthTokenForecasts(ctx context.Context) ApiGetEthTokenForecastsRequest {
	return ApiGetEthTokenForecastsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthTokenForecastsExecute(r ApiGetEthTokenForecastsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthTokenForecasts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/eth/getTokenForecasts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthTokenForecastsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthTokenSummaryRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthTokenSummaryRequest *GetEthTokenSummaryRequest
}

func (r ApiGetEthTokenSummaryRequest) GetEthTokenSummaryRequest(getEthTokenSummaryRequest GetEthTokenSummaryRequest) ApiGetEthTokenSummaryRequest {
	r.getEthTokenSummaryRequest = &getEthTokenSummaryRequest
	return r
}

func (r ApiGetEthTokenSummaryRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthTokenSummaryExecute(r)
}

/*
GetEthTokenSummary Summary Statistics by Token

Returns summary analytics for a given token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthTokenSummaryRequest
*/
func (a *EthereumApiService) GetEthTokenSummary(ctx context.Context) ApiGetEthTokenSummaryRequest {
	return ApiGetEthTokenSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthTokenSummaryExecute(r ApiGetEthTokenSummaryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthTokenSummary")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/eth/getTokenSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthTokenSummaryRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthTokenTransactionsRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthTokenTransactionsRequest *GetEthTokenTransactionsRequest
}

func (r ApiGetEthTokenTransactionsRequest) GetEthTokenTransactionsRequest(getEthTokenTransactionsRequest GetEthTokenTransactionsRequest) ApiGetEthTokenTransactionsRequest {
	r.getEthTokenTransactionsRequest = &getEthTokenTransactionsRequest
	return r
}

func (r ApiGetEthTokenTransactionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthTokenTransactionsExecute(r)
}

/*
GetEthTokenTransactions Transactions by Token

Returns all transactions for a given token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthTokenTransactionsRequest
*/
func (a *EthereumApiService) GetEthTokenTransactions(ctx context.Context) ApiGetEthTokenTransactionsRequest {
	return ApiGetEthTokenTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthTokenTransactionsExecute(r ApiGetEthTokenTransactionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthTokenTransactions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/eth/getTokenTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthTokenTransactionsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthTokensRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthTokensRequest *GetEthTokensRequest
}

func (r ApiGetEthTokensRequest) GetEthTokensRequest(getEthTokensRequest GetEthTokensRequest) ApiGetEthTokensRequest {
	r.getEthTokensRequest = &getEthTokensRequest
	return r
}

func (r ApiGetEthTokensRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthTokensExecute(r)
}

/*
GetEthTokens Tokens by Collection

Returns all tokens for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthTokensRequest
*/
func (a *EthereumApiService) GetEthTokens(ctx context.Context) ApiGetEthTokensRequest {
	return ApiGetEthTokensRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthTokensExecute(r ApiGetEthTokensRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthTokens")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/eth/getTokens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthTokensRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthWalletLabelsRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthWalletLabelsRequest *GetEthWalletLabelsRequest
}

func (r ApiGetEthWalletLabelsRequest) GetEthWalletLabelsRequest(getEthWalletLabelsRequest GetEthWalletLabelsRequest) ApiGetEthWalletLabelsRequest {
	r.getEthWalletLabelsRequest = &getEthWalletLabelsRequest
	return r
}

func (r ApiGetEthWalletLabelsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthWalletLabelsExecute(r)
}

/*
GetEthWalletLabels Wallet Activity Labels

Classifies a wallet's behaviour according to its on-chain activity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthWalletLabelsRequest
*/
func (a *EthereumApiService) GetEthWalletLabels(ctx context.Context) ApiGetEthWalletLabelsRequest {
	return ApiGetEthWalletLabelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthWalletLabelsExecute(r ApiGetEthWalletLabelsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthWalletLabels")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/eth/getWalletLabels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthWalletLabelsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthWalletNFTsRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthWalletNFTsRequest *GetEthWalletNFTsRequest
}

func (r ApiGetEthWalletNFTsRequest) GetEthWalletNFTsRequest(getEthWalletNFTsRequest GetEthWalletNFTsRequest) ApiGetEthWalletNFTsRequest {
	r.getEthWalletNFTsRequest = &getEthWalletNFTsRequest
	return r
}

func (r ApiGetEthWalletNFTsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthWalletNFTsExecute(r)
}

/*
GetEthWalletNFTs Tokens Owned by Wallet

Returns all tokens owned for a given wallet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthWalletNFTsRequest
*/
func (a *EthereumApiService) GetEthWalletNFTs(ctx context.Context) ApiGetEthWalletNFTsRequest {
	return ApiGetEthWalletNFTsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthWalletNFTsExecute(r ApiGetEthWalletNFTsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthWalletNFTs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/eth/getWalletNFTs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthWalletNFTsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthWalletTransactionsRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthWalletTransactionsRequest *GetEthWalletTransactionsRequest
}

func (r ApiGetEthWalletTransactionsRequest) GetEthWalletTransactionsRequest(getEthWalletTransactionsRequest GetEthWalletTransactionsRequest) ApiGetEthWalletTransactionsRequest {
	r.getEthWalletTransactionsRequest = &getEthWalletTransactionsRequest
	return r
}

func (r ApiGetEthWalletTransactionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthWalletTransactionsExecute(r)
}

/*
GetEthWalletTransactions Historical Token Transactions by Wallet

Returns all historical token transactions for a given wallet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthWalletTransactionsRequest
*/
func (a *EthereumApiService) GetEthWalletTransactions(ctx context.Context) ApiGetEthWalletTransactionsRequest {
	return ApiGetEthWalletTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthWalletTransactionsExecute(r ApiGetEthWalletTransactionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthWalletTransactions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/eth/getWalletTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthWalletTransactionsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthWalletValuationRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getPolWalletNFTsRequest *GetPolWalletNFTsRequest
}

func (r ApiGetEthWalletValuationRequest) GetPolWalletNFTsRequest(getPolWalletNFTsRequest GetPolWalletNFTsRequest) ApiGetEthWalletValuationRequest {
	r.getPolWalletNFTsRequest = &getPolWalletNFTsRequest
	return r
}

func (r ApiGetEthWalletValuationRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthWalletValuationExecute(r)
}

/*
GetEthWalletValuation Value All Tokens Owned by Wallet

Returns valuation of all tokens owned for a given wallet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthWalletValuationRequest
*/
func (a *EthereumApiService) GetEthWalletValuation(ctx context.Context) ApiGetEthWalletValuationRequest {
	return ApiGetEthWalletValuationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthWalletValuationExecute(r ApiGetEthWalletValuationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthWalletValuation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/insights/eth/getWalletValuation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getPolWalletNFTsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthWashTradeRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthWashTradeRequest *GetEthWashTradeRequest
}

func (r ApiGetEthWashTradeRequest) GetEthWashTradeRequest(getEthWashTradeRequest GetEthWashTradeRequest) ApiGetEthWashTradeRequest {
	r.getEthWashTradeRequest = &getEthWashTradeRequest
	return r
}

func (r ApiGetEthWashTradeRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthWashTradeExecute(r)
}

/*
GetEthWashTrade Wash Trades by Transaction

Returns suspected wash trades for a given transaction hash

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthWashTradeRequest
*/
func (a *EthereumApiService) GetEthWashTrade(ctx context.Context) ApiGetEthWashTradeRequest {
	return ApiGetEthWashTradeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthWashTradeExecute(r ApiGetEthWashTradeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthWashTrade")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/eth/getWashTrade"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthWashTradeRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEthWashTransactionsRequest struct {
	ctx context.Context
	ApiService *EthereumApiService
	getEthWashTransactionsRequest *GetEthWashTransactionsRequest
}

func (r ApiGetEthWashTransactionsRequest) GetEthWashTransactionsRequest(getEthWashTransactionsRequest GetEthWashTransactionsRequest) ApiGetEthWashTransactionsRequest {
	r.getEthWashTransactionsRequest = &getEthWashTransactionsRequest
	return r
}

func (r ApiGetEthWashTransactionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetEthWashTransactionsExecute(r)
}

/*
GetEthWashTransactions Wash Trades by Collection

Returns suspected wash trades by token for a given collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEthWashTransactionsRequest
*/
func (a *EthereumApiService) GetEthWashTransactions(ctx context.Context) ApiGetEthWashTransactionsRequest {
	return ApiGetEthWashTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EthereumApiService) GetEthWashTransactionsExecute(r ApiGetEthWashTransactionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EthereumApiService.GetEthWashTransactions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/analytics/eth/getWashTransactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getEthWashTransactionsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
